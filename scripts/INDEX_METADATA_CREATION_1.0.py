#!/usr/bin/env python3
"""
INDEX_METADATA_CREATION_1.0.py
Gestion d√©centralis√©e des m√©tadonn√©es BIM sur IPFS avec index de recherche rapide
"""

import hashlib
import json
import time
from datetime import datetime
from typing import Dict, List, Any, Optional
import requests
import os
from dataclasses import dataclass, asdict

@dataclass
class MaterialR9:
    """Structure des m√©tadonn√©es R9 selon votre m√©moire"""
    NOM: str                           # Nom_Materiau_R9
    ID: str                           # ID_Objet_R9 (16 chiffres)
    ID_maquette: str                  # ID_Maquette_R9 (12 chiffres)
    Longueur_m: float                 # Grande_Dimension_R9
    Caracteristique_Materiau: str     # Caracteristique_Materiau_R9
    Materiau: str                     # Type_Materiau_R9
    Statut_usage: str                 # Statut_Usage_R9 (neuf/en usage/r√©employ√©)
    Date_fabrication: str             # Date_Fabrication_R9
    Date_mise_service: str            # Date_Mise_Service_R9
    Date_reemploi: str                # Date_Reemploi_R9
    Empreinte_Carbone: float          # Empreinte_Carbone_R9
    
    # M√©tadonn√©es techniques ajout√©es
    ipfs_hash_ifc: str = ""           # CID du fichier IFC complet
    ipfs_hash_json: str = ""          # CID des m√©tadonn√©es JSON
    integrity_hash: str = ""          # Hash SHA-256 d'int√©grit√©
    last_updated: str = ""            # Timestamp derni√®re modification
    blockchain_tx: str = ""           # Hash de la transaction blockchain

class MetadataIndexManager:
    """Gestionnaire de l'index de m√©tadonn√©es d√©centralis√©"""
    
    def __init__(self, pinata_jwt: str):
        self.pinata_jwt = pinata_jwt
        self.pinata_url = "https://api.pinata.cloud"
        self.headers = {
            "Authorization": f"Bearer {pinata_jwt}",
            "Content-Type": "application/json"
        }
        self.current_index = {"materials": [], "metadata": {}}
        
    def hash_material_json(self, material: MaterialR9) -> str:
        """Calcule le hash SHA-256 des m√©tadonn√©es pour l'int√©grit√©"""
        material_dict = asdict(material)
        # Exclure les champs techniques du hash d'int√©grit√©
        core_data = {k: v for k, v in material_dict.items() 
                    if k not in ['ipfs_hash_ifc', 'ipfs_hash_json', 'integrity_hash', 'last_updated', 'blockchain_tx']}
        
        json_string = json.dumps(core_data, sort_keys=True, separators=(',', ':'))
        return hashlib.sha256(json_string.encode('utf-8')).hexdigest()
    
    def upload_to_pinata(self, data: Dict[str, Any], filename: str) -> str:
        """Upload des donn√©es JSON vers Pinata IPFS"""
        try:
            # Pr√©paration du payload
            payload = {
                "pinataOptions": {"cidVersion": 1},
                "pinataMetadata": {
                    "name": filename,
                    "keyvalues": {
                        "project": "R9_Blockchain",
                        "type": "metadata" if "materials" in data else "material"
                    }
                },
                "pinataContent": data
            }
            
            response = requests.post(
                f"{self.pinata_url}/pinning/pinJSONToIPFS",
                json=payload,
                headers=self.headers
            )
            response.raise_for_status()
            
            result = response.json()
            return result["IpfsHash"]
            
        except Exception as e:
            print(f"‚ùå Erreur upload Pinata: {e}")
            return ""
    
    def download_from_pinata(self, ipfs_hash: str) -> Optional[Dict[str, Any]]:
        """T√©l√©charge des donn√©es JSON depuis IPFS via gateway"""
        try:
            # Utilisation du gateway IPFS public
            gateway_url = f"https://gateway.pinata.cloud/ipfs/{ipfs_hash}"
            response = requests.get(gateway_url, timeout=30)
            response.raise_for_status()
            
            return response.json()
            
        except Exception as e:
            print(f"‚ùå Erreur t√©l√©chargement IPFS {ipfs_hash}: {e}")
            return None
    
    def add_material_to_index(self, material: MaterialR9) -> Dict[str, str]:
        """Ajoute un mat√©riau √† l'index et upload sur IPFS"""
        
        # 1. Calcul du hash d'int√©grit√©
        material.integrity_hash = self.hash_material_json(material)
        material.last_updated = datetime.now().isoformat()
        
        # 2. Upload du mat√©riau individuel sur IPFS
        material_dict = asdict(material)
        material_ipfs_hash = self.upload_to_pinata(
            material_dict, 
            f"material_{material.ID}.json"
        )
        material.ipfs_hash_json = material_ipfs_hash
        
        print(f"‚úÖ Mat√©riau {material.NOM} upload√©: {material_ipfs_hash}")
        
        # 3. Ajout √† l'index local
        self.current_index["materials"].append({
            "ID": material.ID,
            "NOM": material.NOM,
            "Materiau": material.Materiau,
            "Caracteristique_Materiau": material.Caracteristique_Materiau,
            "Longueur_m": material.Longueur_m,
            "Statut_usage": material.Statut_usage,
            "Empreinte_Carbone": material.Empreinte_Carbone,
            "ipfs_hash_json": material_ipfs_hash,
            "ipfs_hash_ifc": material.ipfs_hash_ifc,
            "integrity_hash": material.integrity_hash,
            "last_updated": material.last_updated
        })
        
        return {
            "material_ipfs_hash": material_ipfs_hash,
            "integrity_hash": material.integrity_hash
        }
    
    def update_global_index(self) -> str:
        """Met √† jour l'index global sur IPFS"""
        
        # M√©tadonn√©es de l'index
        self.current_index["metadata"] = {
            "total_materials": len(self.current_index["materials"]),
            "last_updated": datetime.now().isoformat(),
            "version": "1.0",
            "project": "R9_Blockchain_Consortium"
        }
        
        # Upload de l'index complet
        index_ipfs_hash = self.upload_to_pinata(
            self.current_index,
            "r9_materials_index.json"
        )
        
        print(f"üîÑ Index global mis √† jour: {index_ipfs_hash}")
        return index_ipfs_hash
    
    def load_index_from_ipfs(self, index_ipfs_hash: str) -> bool:
        """Charge l'index depuis IPFS"""
        index_data = self.download_from_pinata(index_ipfs_hash)
        if index_data:
            self.current_index = index_data
            print(f"‚úÖ Index charg√©: {len(self.current_index['materials'])} mat√©riaux")
            return True
        return False
    
    def search_materials(self, filters: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Recherche dans l'index local avec filtres"""
        results = []
        
        for material in self.current_index["materials"]:
            match = True
            
            for key, value in filters.items():
                if key not in material:
                    continue
                    
                if key in ["Longueur_m", "Empreinte_Carbone"]:
                    # Filtres num√©riques
                    if isinstance(value, str) and value.startswith(">"):
                        if material[key] <= float(value[1:]):
                            match = False
                            break
                    elif isinstance(value, str) and value.startswith("<"):
                        if material[key] >= float(value[1:]):
                            match = False
                            break
                    elif material[key] != value:
                        match = False
                        break
                else:
                    # Filtres textuels (insensible √† la casse)
                    if isinstance(value, str) and value.lower() not in str(material[key]).lower():
                        match = False
                        break
            
            if match:
                results.append(material)
        
        return results
    
    def get_full_material_data(self, material_id: str) -> Optional[MaterialR9]:
        """R√©cup√®re les donn√©es compl√®tes d'un mat√©riau depuis IPFS"""
        
        # 1. Trouver dans l'index local
        material_ref = None
        for material in self.current_index["materials"]:
            if material["ID"] == material_id:
                material_ref = material
                break
        
        if not material_ref:
            print(f"‚ùå Mat√©riau {material_id} non trouv√© dans l'index")
            return None
        
        # 2. T√©l√©charger depuis IPFS
        full_data = self.download_from_pinata(material_ref["ipfs_hash_json"])
        if not full_data:
            return None
        
        # 3. V√©rifier l'int√©grit√©
        received_hash = material_ref["integrity_hash"]
        calculated_hash = self.hash_material_json(MaterialR9(**{k: v for k, v in full_data.items() 
                                                              if k in MaterialR9.__dataclass_fields__}))
        
        if received_hash != calculated_hash:
            print(f"‚ö†Ô∏è Int√©grit√© compromise pour {material_id}")
            return None
        
        return MaterialR9(**full_data)

# ===============================
# EXEMPLE D'UTILISATION COMPL√àTE
# ===============================

def demo_system_r9():
    """D√©monstration compl√®te du syst√®me d'index R9"""
    
    # Configuration
    PINATA_JWT = os.getenv("PINATA_JWT", "your_pinata_jwt_here")
    manager = MetadataIndexManager(PINATA_JWT)
    
    print("üöÄ === DEMO SYST√àME INDEX R9 ===\n")
    
    # 1. Cr√©ation de mat√©riaux de test (projet Diog√®ne)
    materials_diogene = [
        MaterialR9(
            NOM="poutre IPE 200",
            ID="1234567891234567",
            ID_maquette="123456789123",
            Longueur_m=12.23,
            Caracteristique_Materiau="S355",
            Materiau="acier",
            Statut_usage="r√©employ√©",
            Date_fabrication="13012011",
            Date_mise_service="13012011",
            Date_reemploi="13012024",
            Empreinte_Carbone=400.0,
            ipfs_hash_ifc="QmSimulatedIFCHash123..."
        ),
        MaterialR9(
            NOM="poutre bois lamell√© coll√©",
            ID="2345678912345678",
            ID_maquette="123456789123",
            Longueur_m=8.50,
            Caracteristique_Materiau="GL24h",
            Materiau="bois",
            Statut_usage="neuf",
            Date_fabrication="15032020",
            Date_mise_service="15032020",
            Date_reemploi="",
            Empreinte_Carbone=120.0,
            ipfs_hash_ifc="QmSimulatedIFCHash456..."
        ),
        MaterialR9(
            NOM="section tubulaire acier",
            ID="3456789123456789",
            ID_maquette="123456789123",
            Longueur_m=6.75,
            Caracteristique_Materiau="S275",
            Materiau="acier",
            Statut_usage="en usage",
            Date_fabrication="20052018",
            Date_mise_service="20052018",
            Date_reemploi="",
            Empreinte_Carbone=350.0,
            ipfs_hash_ifc="QmSimulatedIFCHash789..."
        )
    ]
    
    # 2. Ajout des mat√©riaux √† l'index
    print("üì¶ Ajout des mat√©riaux √† l'index...")
    for material in materials_diogene:
        result = manager.add_material_to_index(material)
        print(f"  ‚úÖ {material.NOM} - Hash: {result['integrity_hash'][:10]}...")
    
    # 3. Mise √† jour de l'index global
    print("\nüîÑ Mise √† jour de l'index global...")
    global_index_hash = manager.update_global_index()
    print(f"üìç Index global IPFS: {global_index_hash}")
    
    # 4. Simulation de recherches
    print("\nüîç === TESTS DE RECHERCHE ===")
    
    # Recherche par mat√©riau
    print("\nüî∏ Recherche: Mat√©riau = 'acier'")
    steel_materials = manager.search_materials({"Materiau": "acier"})
    for mat in steel_materials:
        print(f"  ‚Üí {mat['NOM']} - {mat['Caracteristique_Materiau']} - {mat['Statut_usage']}")
    
    # Recherche par longueur
    print("\nüî∏ Recherche: Longueur > 8m")
    long_materials = manager.search_materials({"Longueur_m": ">8"})
    for mat in long_materials:
        print(f"  ‚Üí {mat['NOM']} - {mat['Longueur_m']}m")
    
    # Recherche combin√©e
    print("\nüî∏ Recherche combin√©e: Acier + R√©employ√©")
    reused_steel = manager.search_materials({
        "Materiau": "acier",
        "Statut_usage": "r√©employ√©"
    })
    for mat in reused_steel:
        print(f"  ‚Üí {mat['NOM']} - Empreinte: {mat['Empreinte_Carbone']}kg CO‚ÇÇ")
    
    # 5. R√©cup√©ration compl√®te d'un mat√©riau
    print("\nüìã === R√âCUP√âRATION COMPL√àTE ===")
    if steel_materials:
        material_id = steel_materials[0]["ID"]
        print(f"üî∏ R√©cup√©ration compl√®te du mat√©riau: {material_id}")
        full_material = manager.get_full_material_data(material_id)
        if full_material:
            print(f"  ‚úÖ Donn√©es compl√®tes r√©cup√©r√©es:")
            print(f"     Nom: {full_material.NOM}")
            print(f"     Hash IFC: {full_material.ipfs_hash_ifc}")
            print(f"     Int√©grit√© v√©rifi√©e: ‚úÖ")
    
    print(f"\nüéØ === R√âSUM√â FINAL ===")
    print(f"‚úÖ {len(materials_diogene)} mat√©riaux index√©s")
    print(f"üìç Index global IPFS: {global_index_hash}")
    print(f"üîç Recherche rapide op√©rationnelle")
    print(f"üîê Int√©grit√© des donn√©es v√©rifi√©e")
    
    return global_index_hash

if __name__ == "__main__":
    demo_system_r9()